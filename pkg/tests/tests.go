/*

Package tests provides a helper function for testing.

*/

package tests

import (
	"bytes"
	"fmt"
	"reflect"
	"strings"
	"testing"
	"text/template"

	"github.com/azrod/go-prometheus-metrics-builder/types"
	"github.com/prometheus/client_golang/prometheus/testutil"
)

type (
	Testable struct {
		Collector types.Collector
		Tests     []Test
	}

	Test struct {
		// Name of the test. It should be unique for the tests. Autogenerated if not provided.
		Name string

		// Name of the metric. Autogenerated if not provided.
		MetricName string

		// Value of the metric. Autogenerated if not provided.
		MetricValue float64

		// Provide the labels for the Vec metrics. Autogenerated if not provided.
		Labels map[string]string

		// ExpectedData content of the metric.
		// Use the prometheus text format.
		//
		//  Example:
		// 	# HELP metric_name help
		// 	# TYPE metric_name counter
		ExpectedData string

		// ExpectedValue value of the metric.
		// Use the prometheus text format.
		// If the value is not provided, it will be generated from MetricValue.
		//
		//  Example:
		// 1\n
		ExpectedValue string

		// ExpectedError error. Boolean to determine if the test should fail.
		ExpectError bool
	}
)

var metrics map[types.MetricType]map[string]*Testable

func init() {
	metrics = make(map[types.MetricType]map[string]*Testable)
}

func Helper(metricStruct interface{}) map[types.MetricType]map[string]*Testable {
	if reflect.TypeOf(metricStruct).Kind() != reflect.Ptr {
		panic("Helper only accepts pointers")
	}

	// Reflect the struct type
	t := reflect.TypeOf(metricStruct).Elem()

	// Reflect the struct value from the pointer
	v := reflect.ValueOf(metricStruct).Elem()

	iterateStruct(t, v)

	// // Iterate over the struct fields
	// for i := 0; i < t.NumField(); i++ {
	// 	// Get the field value
	// 	fieldValue := v.Field(i)

	// }

	return metrics
}

func iterateStruct(t reflect.Type, v reflect.Value) {
	// Iterate over the struct fields
	for i := 0; i < t.NumField(); i++ {
		// Get the field
		field := t.Field(i)

		switch field.Type.Kind() {
		case reflect.Struct:
			if field.Type.String() == "pmbuilder.InstanceInterface" {
				continue
			}
			iterateStruct(field.Type, v.Field(i))
		case reflect.Ptr:
			// Get the metric
			metric := v.Field(i).Interface().(types.Initializable)

			if metrics[metric.GetType()] == nil {
				metrics[metric.GetType()] = make(map[string]*Testable)
			}

			metrics[metric.GetType()][metric.GetName()] = &Testable{
				Collector: metric.Collector(),
				Tests:     make([]Test, 0),
			}

			var tests []Test

			switch metric.GetType() {
			case types.TypeCounter:
				tests = []Test{
					{
						Name:        "Valid Counter",
						MetricName:  metric.GetName(),
						MetricValue: 1,
					},
					{
						Name:          "Invalid Counter",
						MetricName:    metric.GetName(),
						MetricValue:   1,
						ExpectedValue: " 4\n",
						ExpectError:   true,
					},
				}
			}

			for _, test := range tests {
				metrics[metric.GetType()][metric.GetName()].AddTest(test)
			}
		}
	}
}

func (t *Testable) AddTest(test Test) {
	if test.ExpectedData == "" {
		test.ExpectedData = t.generateExpectedData()
	}

	if test.ExpectedValue == "" {
		// TODO Add expectedvalue by type
		test.ExpectedValue = fmt.Sprintf(" %f\n", test.MetricValue)
	}

	if len(test.Labels) == 0 {
		test.Labels = make(map[string]string)
		test.Labels["test"] = "demo"
	}

	t.Tests = append(t.Tests, test)
}

func (t Testable) Run(tt *testing.T) {
	for _, test := range t.Tests {
		tt.Run(test.Name, func(tb *testing.T) {
			// Set the metric value
			t.Collector.SetValue(test.MetricValue, test.Labels)

			err := testutil.CollectAndCompare(
				t.Collector,
				strings.NewReader(test.ExpectedData+test.MetricName+test.ExpectedValue),
				test.MetricName,
			)
			if err != nil {
				if !test.ExpectError {
					tt.Errorf("unexpected error: %v", err)
				}
			}
		},
		)
	}
}

func (t *Testable) templateBuilder(tmpl string) string {
	// Use go template to build the string

	tt, err := template.New("test").Parse(tmpl)
	if err != nil {
		panic(err)
	}

	// new io writer
	var buff bytes.Buffer

	if err := tt.Execute(&buff, t); err != nil {
		panic(err)
	}

	return buff.String()
}

func (t *Testable) generateExpectedData() string {
	tmpl := `
# HELP {{.Collector.GetName}} {{.Collector.GetHelp}}
# TYPE {{.Collector.GetName}} {{.Collector.GetType}}
`

	return t.templateBuilder(tmpl)
}
